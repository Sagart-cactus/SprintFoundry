// ============================================================
// AgentSDLC — Git Manager
// Clone repos, create branches, commit, push, create PRs
// ============================================================

import { spawnSync } from "child_process";
import type {
  RepoConfig,
  BranchStrategy,
  TicketDetails,
  TaskRun,
} from "../shared/types.js";

export class GitManager {
  constructor(
    private repoConfig: RepoConfig,
    private branchStrategy: BranchStrategy
  ) {}

  async cloneAndBranch(
    workspacePath: string,
    ticket: TicketDetails
  ): Promise<string> {
    const branchName = this.buildBranchName(ticket);

    // Clone the repository
    const cloneUrl = this.repoConfig.token
      ? this.injectToken(this.repoConfig.url, this.repoConfig.token)
      : this.repoConfig.url;

    this.exec(["git", "clone", "--depth", "50", cloneUrl, "."], workspacePath);
    this.exec(
      ["git", "checkout", "-b", branchName, `origin/${this.repoConfig.default_branch}`],
      workspacePath
    );

    // Enable Entire session tracking on the cloned repo (best-effort)
    this.tryEnableEntire(workspacePath);

    return branchName;
  }

  async commitStepCheckpoint(
    workspacePath: string,
    runId: string,
    stepNumber: number,
    agentId: string
  ): Promise<boolean> {
    this.exec(["git", "add", "-A"], workspacePath);

    // Check whether there is anything staged to commit
    const diffResult = this.execRaw(["git", "diff", "--staged", "--quiet"], workspacePath);
    if (diffResult.status === 0) {
      // Exit code 0 means no diff — nothing to commit
      console.log(`[git] Step ${stepNumber} checkpoint: no changes to commit, skipping.`);
      return false;
    }

    const message = `chore(agentsdlc): run ${runId} step ${stepNumber} ${agentId}`;
    this.exec(["git", "commit", "-m", message], workspacePath);
    console.log(`[git] Step ${stepNumber} checkpoint committed: "${message}"`);
    return true;
  }

  async commitAndPush(
    workspacePath: string,
    message: string
  ): Promise<void> {
    this.exec(["git", "add", "-A"], workspacePath);
    // Only commit if there are staged changes (step checkpoints may have already committed everything)
    const diffResult = this.execRaw(["git", "diff", "--staged", "--quiet"], workspacePath);
    if (diffResult.status !== 0) {
      this.exec(["git", "commit", "-m", message], workspacePath);
    }
    this.exec(["git", "push", "-u", "origin", "HEAD"], workspacePath);
  }

  async createPullRequest(
    workspacePath: string,
    run: TaskRun
  ): Promise<string> {
    const title = `[AgentSDLC] ${run.ticket.title}`;
    const body = this.buildPRBody(run);

    // Use GitHub CLI if available, otherwise return placeholder
    try {
      const result = this.exec(
        ["gh", "pr", "create", "--title", title, "--body", body, "--base", this.repoConfig.default_branch],
        workspacePath
      );
      return result.trim();
    } catch {
      // Fallback: push branch and return a message
      await this.commitAndPush(
        workspacePath,
        `feat: ${run.ticket.title} [AgentSDLC run ${run.run_id}]`
      );
      return `Branch pushed. Create PR manually for ${run.ticket.id}.`;
    }
  }

  private buildBranchName(ticket: TicketDetails): string {
    const { prefix, include_ticket_id, naming } = this.branchStrategy;
    const parts: string[] = [];

    if (include_ticket_id) {
      parts.push(ticket.id.toLowerCase());
    }

    // Slugify the title
    const slug = ticket.title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, naming === "snake_case" ? "_" : "-")
      .replace(/^[-_]+|[-_]+$/g, "")
      .slice(0, 50);

    parts.push(slug);

    return prefix + parts.join(naming === "snake_case" ? "_" : "-");
  }

  private buildPRBody(run: TaskRun): string {
    const stepSummaries = run.steps
      .filter((s) => s.result)
      .map((s) => `- **${s.agent}**: ${s.result!.summary}`)
      .join("\\n");

    return [
      `## Summary`,
      `Ticket: ${run.ticket.id} — ${run.ticket.title}`,
      ``,
      `## Agent Results`,
      stepSummaries,
      ``,
      `## Stats`,
      `- Tokens used: ${run.total_tokens_used.toLocaleString()}`,
      `- Cost: $${run.total_cost_usd.toFixed(2)}`,
      `- Steps: ${run.steps.length}`,
      ``,
      `---`,
      `Generated by AgentSDLC`,
    ].join("\\n");
  }

  private tryEnableEntire(cwd: string): void {
    try {
      const [command, ...args] = ["entire", "enable", "--strategy", "manual-commit"];
      const result = spawnSync(command, args, {
        cwd,
        encoding: "utf-8",
        timeout: 10_000,
      });
      if (result.status === 0) {
        console.log(`[git] Entire enabled with manual strategy`);
      } else {
        console.log(`[git] Entire not available, skipping`);
      }
    } catch {
      // entire CLI not installed — silently skip
    }
  }

  private injectToken(url: string, token: string): string {
    // Convert git@github.com:org/repo.git to https://token@github.com/org/repo.git
    if (url.startsWith("git@")) {
      const match = url.match(/git@(.+):(.+)/);
      if (match) {
        return `https://${token}@${match[1]}/${match[2]}`;
      }
    }
    // For HTTPS URLs, inject token
    return url.replace("https://", `https://${token}@`);
  }

  private exec(args: string[], cwd: string): string {
    console.log(`[git] Running: ${args.join(" ")}`);
    const [command, ...commandArgs] = args;
    const result = spawnSync(command, commandArgs, {
      cwd,
      encoding: "utf-8",
      timeout: 60_000,
      env: {
        ...process.env,
        GIT_SSH_COMMAND: this.repoConfig.ssh_key_path
          ? `ssh -i ${this.repoConfig.ssh_key_path} -o StrictHostKeyChecking=no`
          : undefined,
      },
    });

    if (result.error) {
      throw result.error;
    }
    if (result.status !== 0) {
      throw new Error(
        `Command failed (${command}): ${result.stderr || "unknown error"}`
      );
    }
    return result.stdout ?? "";
  }

  // Like exec, but returns the raw result without throwing on non-zero exit codes.
  private execRaw(args: string[], cwd: string): { status: number | null; stdout: string } {
    const [command, ...commandArgs] = args;
    const result = spawnSync(command, commandArgs, {
      cwd,
      encoding: "utf-8",
      timeout: 60_000,
      env: {
        ...process.env,
        GIT_SSH_COMMAND: this.repoConfig.ssh_key_path
          ? `ssh -i ${this.repoConfig.ssh_key_path} -o StrictHostKeyChecking=no`
          : undefined,
      },
    });

    if (result.error) {
      throw result.error;
    }
    return { status: result.status, stdout: result.stdout ?? "" };
  }
}
