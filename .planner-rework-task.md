You are the orchestrator for AgentSDLC. A step has failed and you need to plan minimal rework steps.

## Available Agents
- Product Agent (id: "product", role: "product"): Analyze feature requests and bug reports, Write product requirement documents, Define user stories and acceptance criteria
- Architecture Agent (id: "architect", role: "architect"): Design system architecture, Create data models and ER diagrams, Define API contracts (OpenAPI/YAML)
- Developer Agent (id: "developer", role: "developer"): Write production TypeScript/JavaScript code, Build React/Next.js frontend components, Build API routes and server-side logic
- QA Agent (id: "qa", role: "qa"): Write unit tests (vitest), Write integration/API tests, Write E2E tests (playwright)
- Security Agent (id: "security", role: "security"): Static analysis security scanning, Dependency vulnerability checking, Auth flow review
- UI/UX Agent (id: "ui-ux", role: "ui-ux"): Create wireframes and user flows, Design component specifications, Generate React component previews
- DevOps Agent (id: "devops", role: "devops"): Create/modify CI/CD pipelines, Write Dockerfiles and compose files, Configure cloud infrastructure (Terraform/Pulumi)

## Completed Steps
- Step 1 (developer): Added per-step git commit checkpoints to the orchestration service. After each step completes with status 'complete', GitManager stages all changes and creates a commit with message 'chore(agentsdlc): run <run_id> step <n> <agent_id>'. Skips the commit when there are no staged changes. Commit failures emit a step.failed event and mark the step/run as failed. PR creation compatibility is maintained.

## Failed Step
Step 2 (qa): Validate the per-step git commit implementation against the acceptance criteria: (1) verify that a multi-step run with code changes produces one commit per successful changing step in git log, (2) verify that steps producing no diff do not create empty commits, (3) verify that commit failures are surfaced in events/logs and the run status reflects failure, (4) verify that existing PR creation behavior still works when per-step commits are already present on the branch. Write unit tests for the commit-checkpoint logic in orchestration-service.ts covering the happy path, no-diff skip, and commit-failure error propagation cases.
Status: needs_rework
Reason: One existing test is broken by the developer's implementation. The test 'cloneAndBranch calls git clone + checkout' in tests/git-manager.test.ts:46 asserts toHaveBeenCalledTimes(2) but cloneAndBranch now makes 3 spawnSync calls (git clone, git checkout, entire enable). The developer must either update the test assertion to accommodate the new call or guard tryEnableEntire so it does not fire during tests.
Issues: MINOR: Pre-existing test regression — 'cloneAndBranch calls git clone + checkout' fails because tryEnableEntire() added by developer makes a 3rd spawnSync call that the existing test did not anticipate.

## Rework Attempt 1 of 3

## Previous Rework Attempts
### Attempt 1
Status: needs_rework
Summary: 14 new unit tests written and passing (7 for GitManager.commitStepCheckpoint, 7 for OrchestrationService commit-checkpoint integration). All new tests pass. Found 1 pre-existing regression: the developer's addition of tryEnableEntire() in cloneAndBranch breaks the existing 'cloneAndBranch calls git clone + checkout' test assertion. Total suite: 143 passed, 1 failed.
Issues: MINOR: Pre-existing test regression — 'cloneAndBranch calls git clone + checkout' fails because tryEnableEntire() added by developer makes a 3rd spawnSync call that the existing test did not anticipate.

Return ONLY a valid JSON array of 1-2 rework steps. No markdown fences.
Each step: { "step_number": 900+N, "agent": "id", "model": "string", "task": "description", "context_inputs": [{"type":"ticket"},{"type":"step_output","step_number":N}], "depends_on": [], "estimated_complexity": "medium" }